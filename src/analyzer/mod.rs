//! Dependency and binary analysis module
//!
//! Provides tools for analyzing WASM bundles and their dependencies:
//! - Dependency tree parsing and analysis
//! - Feature flag optimization detection
//! - Heavy dependency identification
//! - Size estimation and reporting
//!
//! # Plugin System
//!
//! The analyzer module supports a plugin architecture through the `Analyzer` trait.
//! Custom analyzers can be registered with `AnalyzerRegistry` for dynamic execution.

use std::any::Any;
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

/// Context provided to analyzers during execution
#[derive(Clone, Debug)]
pub struct AnalysisContext {
    /// Root directory of the project being analyzed
    pub project_root: PathBuf,
    /// Path to the WASM binary (if available)
    pub wasm_binary: Option<PathBuf>,
    /// Additional context data
    pub metadata: HashMap<String, String>,
}

impl AnalysisContext {
    /// Create a new analysis context
    pub fn new(project_root: PathBuf) -> Self {
        Self {
            project_root,
            wasm_binary: None,
            metadata: HashMap::new(),
        }
    }

    /// Set the WASM binary path
    pub fn with_wasm_binary(mut self, wasm_binary: PathBuf) -> Self {
        self.wasm_binary = Some(wasm_binary);
        self
    }

    /// Add metadata
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }
}

/// Results from an analyzer execution
#[derive(Clone, Debug)]
pub struct AnalysisResult {
    /// Analyzer name
    pub analyzer_name: String,
    /// Success status
    pub success: bool,
    /// Result data (type-erased for flexibility)
    pub data: Option<Arc<dyn Any + Send + Sync>>,
    /// Error message if failed
    pub error: Option<String>,
}

impl AnalysisResult {
    /// Create a successful result
    pub fn success(analyzer_name: impl Into<String>, data: Arc<dyn Any + Send + Sync>) -> Self {
        Self {
            analyzer_name: analyzer_name.into(),
            success: true,
            data: Some(data),
            error: None,
        }
    }

    /// Create a failed result
    pub fn failure(analyzer_name: impl Into<String>, error: impl Into<String>) -> Self {
        Self {
            analyzer_name: analyzer_name.into(),
            success: false,
            data: None,
            error: Some(error.into()),
        }
    }
}

/// Metadata for analyzers (ISP: separate metadata from behavior)
pub trait AnalyzerMetadata {
    /// Get the analyzer name
    fn name(&self) -> &str;

    /// Get the analyzer description
    fn description(&self) -> &str;

    /// Get analyzer version
    fn version(&self) -> &str {
        "1.0.0"
    }

    /// Get analyzer dependencies (names of other analyzers that should run first)
    fn dependencies(&self) -> Vec<&str> {
        Vec::new()
    }
}

/// Trait for pluggable analyzers
pub trait Analyzer: AnalyzerMetadata + Send + Sync {
    /// Check if this analyzer can run in the given context
    fn can_analyze(&self, context: &AnalysisContext) -> bool;

    /// Run the analysis
    fn analyze(&self, context: &AnalysisContext) -> AnalysisResult;
}

/// Registry for managing analyzers
#[derive(Default)]
pub struct AnalyzerRegistry {
    analyzers: Mutex<HashMap<String, Arc<dyn Analyzer>>>,
}

/// Priority levels for recommendations
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Priority {
    /// Critical issues that block production use
    P0,
    /// High priority issues that should be addressed soon
    P1,
    /// Medium priority improvements
    P2,
    /// Low priority nice-to-haves
    P3,
}

impl Priority {
    /// Convert to string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            Priority::P0 => "P0",
            Priority::P1 => "P1",
            Priority::P2 => "P2",
            Priority::P3 => "P3",
        }
    }
}

/// A recommendation generated by analysis
#[derive(Debug, Clone)]
pub struct Recommendation {
    /// Priority level
    pub priority: Priority,
    /// Category (e.g., "size", "performance", "security")
    pub category: String,
    /// Description of the recommendation
    pub description: String,
    /// Estimated impact (e.g., KB saved, % improvement)
    pub estimated_impact: Option<f64>,
    /// Unit of impact (e.g., "KB", "%", "ms")
    pub impact_unit: Option<String>,
}

impl Recommendation {
    /// Create a new recommendation
    pub fn new(
        priority: Priority,
        category: impl Into<String>,
        description: impl Into<String>,
    ) -> Self {
        Self {
            priority,
            category: category.into(),
            description: description.into(),
            estimated_impact: None,
            impact_unit: None,
        }
    }

    /// Set the estimated impact
    pub fn with_impact(mut self, impact: f64, unit: impl Into<String>) -> Self {
        self.estimated_impact = Some(impact);
        self.impact_unit = Some(unit.into());
        self
    }
}

/// Trait for pluggable recommendation engines
pub trait RecommendationEngine: Send + Sync {
    /// Engine name
    fn name(&self) -> &str;

    /// Generate recommendations from analysis results
    fn generate_recommendations(
        &self,
        context: &AnalysisContext,
        results: &[AnalysisResult],
    ) -> Vec<Recommendation>;

    /// Filter recommendations by priority
    fn filter_by_priority(
        &self,
        recommendations: Vec<Recommendation>,
        min_priority: Priority,
    ) -> Vec<Recommendation> {
        recommendations
            .into_iter()
            .filter(|r| r.priority <= min_priority)
            .collect()
    }

    /// Sort recommendations by priority
    fn sort_by_priority(&self, mut recommendations: Vec<Recommendation>) -> Vec<Recommendation> {
        recommendations.sort_by_key(|r| r.priority);
        recommendations
    }
}

/// Registry for managing recommendation engines
#[derive(Default)]
pub struct RecommendationEngineRegistry {
    engines: Mutex<HashMap<String, Arc<dyn RecommendationEngine>>>,
}

impl RecommendationEngineRegistry {
    /// Create a new empty registry
    pub fn new() -> Self {
        Self::default()
    }

    /// Register an engine
    pub fn register(&self, engine: Arc<dyn RecommendationEngine>) {
        let name = engine.name().to_string();
        match self.engines.lock() {
            Ok(mut engines) => {
                engines.insert(name, engine);
            }
            Err(poisoned) => {
                log::error!("Recommendation engine registry lock poisoned, recovering");
                // Recover from poisoned lock by clearing the poison
                let mut engines = poisoned.into_inner();
                engines.insert(name, engine);
            }
        }
    }

    /// Get an engine by name
    pub fn get(&self, name: &str) -> Option<Arc<dyn RecommendationEngine>> {
        match self.engines.lock() {
            Ok(engines) => engines.get(name).cloned(),
            Err(poisoned) => {
                log::warn!("Recommendation engine registry lock poisoned, attempting recovery");
                poisoned.into_inner().get(name).cloned()
            }
        }
    }

    /// Generate recommendations using a specific engine
    pub fn generate(
        &self,
        engine_name: &str,
        context: &AnalysisContext,
        results: &[AnalysisResult],
    ) -> Option<Vec<Recommendation>> {
        let engine = self.get(engine_name)?;
        Some(engine.generate_recommendations(context, results))
    }

    /// Remove an engine
    pub fn unregister(&self, name: &str) -> bool {
        match self.engines.lock() {
            Ok(mut engines) => engines.remove(name).is_some(),
            Err(poisoned) => {
                log::warn!("Recommendation engine registry lock poisoned during unregister");
                poisoned.into_inner().remove(name).is_some()
            }
        }
    }
}

impl AnalyzerRegistry {
    /// Create a new empty registry
    pub fn new() -> Self {
        Self::default()
    }

    /// Register an analyzer
    pub fn register(&self, analyzer: Arc<dyn Analyzer>) {
        let name = analyzer.name().to_string();
        match self.analyzers.lock() {
            Ok(mut analyzers) => {
                analyzers.insert(name, analyzer);
            }
            Err(poisoned) => {
                log::error!("Analyzer registry lock poisoned, recovering");
                let mut analyzers = poisoned.into_inner();
                analyzers.insert(name, analyzer);
            }
        }
    }

    /// Get an analyzer by name
    pub fn get(&self, name: &str) -> Option<Arc<dyn Analyzer>> {
        match self.analyzers.lock() {
            Ok(analyzers) => analyzers.get(name).cloned(),
            Err(poisoned) => {
                log::warn!("Analyzer registry lock poisoned, attempting recovery");
                poisoned.into_inner().get(name).cloned()
            }
        }
    }

    /// List all registered analyzers
    pub fn list(&self) -> Vec<String> {
        match self.analyzers.lock() {
            Ok(analyzers) => analyzers.keys().cloned().collect(),
            Err(poisoned) => {
                log::warn!("Analyzer registry lock poisoned during list operation");
                poisoned.into_inner().keys().cloned().collect()
            }
        }
    }

    /// Run a specific analyzer
    pub fn run(&self, name: &str, context: &AnalysisContext) -> Option<AnalysisResult> {
        let analyzer = self.get(name)?;
        if !analyzer.can_analyze(context) {
            return Some(AnalysisResult::failure(
                name,
                "Analyzer cannot run in this context",
            ));
        }
        Some(analyzer.analyze(context))
    }

    /// Run all registered analyzers
    pub fn run_all(&self, context: &AnalysisContext) -> Vec<AnalysisResult> {
        let analyzers: Vec<_> = match self.analyzers.lock() {
            Ok(analyzers) => analyzers.values().cloned().collect(),
            Err(poisoned) => {
                log::warn!("Analyzer registry lock poisoned during run_all");
                poisoned.into_inner().values().cloned().collect()
            }
        };
        analyzers
            .into_iter()
            .filter(|a| a.can_analyze(context))
            .map(|a| a.analyze(context))
            .collect()
    }

    /// Remove an analyzer
    pub fn unregister(&self, name: &str) -> bool {
        match self.analyzers.lock() {
            Ok(mut analyzers) => analyzers.remove(name).is_some(),
            Err(poisoned) => {
                log::warn!("Analyzer registry lock poisoned during unregister");
                poisoned.into_inner().remove(name).is_some()
            }
        }
    }

    /// Clear all analyzers
    pub fn clear(&self) {
        match self.analyzers.lock() {
            Ok(mut analyzers) => analyzers.clear(),
            Err(poisoned) => {
                log::warn!("Analyzer registry lock poisoned during clear");
                poisoned.into_inner().clear();
            }
        }
    }
}

pub mod allocator;
pub mod applicator;
pub mod asset_display;
pub mod asset_metrics;
pub mod asset_report;
pub mod asset_types;
pub mod asset_visitor;
pub mod assets;
pub mod bloat;
pub mod bloat_report;
pub mod deps;
pub mod deps_report;
pub mod deps_types;
pub mod feature_report;
pub mod features;
pub mod heavy_deps;
pub mod panic_advisor;
pub mod panic_report;
pub mod panics;
pub mod report_utils;
pub mod twiggy;
pub mod twiggy_report;

// Existing exports
pub use applicator::SuggestionApplicator;
pub use asset_report::{print_asset_report, print_json_output, show_externalization_guide};
pub use assets::AssetDetector;
pub use bloat::BloatAnalyzer;
pub use bloat_report::{
    format_console_report as format_bloat_console, format_json_report as format_bloat_json,
};
pub use deps::DependencyAnalyzer;
pub use feature_report::{
    format_console_report as format_feature_console, format_json_report as format_feature_json,
};
pub use features::FeatureAnalyzer;
pub use panic_report::{print_json_report as print_panic_json, print_panic_report};
pub use panics::PanicDetector;
pub use twiggy::{AnalysisMode, MonomorphizationGroup, TwiggyAnalyzer};
pub use twiggy_report::{print_analysis_report, print_comparison_report};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_analyzer_module_exports_are_accessible() {
        // Ensure all key exports compile and are accessible
        let _: Option<DependencyAnalyzer> = None;
        let _: Option<SuggestionApplicator> = None;
        let _: Option<AssetDetector> = None;
        let _: Option<TwiggyAnalyzer> = None;
        let _: Option<BloatAnalyzer> = None;
        let _: Option<FeatureAnalyzer> = None;
        let _: Option<PanicDetector> = None;
    }
}
